import data.fintype.basic

open finset

universe u

theorem hall {α β : Type*} [fintype α] [fintype β] (r : α → β → Prop) [∀ a, decidable_pred (r a)]:
  (∀ (A : finset α), A.card ≤ (univ.filter (λ b, ∃ a ∈ A, r a b)).card)
    ↔ (∃ (f : α → β), function.injective f ∧ ∀ x, r x (f x)) :=
begin
  classical,
  split,
  { let n := fintype.card α,
    have hn : fintype.card α ≤ n,
    { apply le_of_eq rfl },
    clear_value n,
    tactic.unfreeze_local_instances,
    intro h,
    induction n with n ih generalizing α β,
    { rw [le_zero_iff_eq, fintype.card_eq_zero_iff] at hn,
      exact ⟨λ a, (hn a).elim, λ a, (hn a).elim, λ a, (hn a).elim⟩ },
    { have : (α → false) ∨ fintype.card α = 1 ∨ nontrivial α,
      { rw ← or_assoc,
        apply or.imp (λ h₁, _) (λ h₁, _) (le_or_lt (fintype.card α) 1),
        { rw [← fintype.card_eq_zero_iff, or_iff_not_imp_left],
          intro a,
          apply le_antisymm h₁,
          apply nat.pos_of_ne_zero a },
        rwa ← fintype.one_lt_card_iff_nontrivial },
      rcases this with (_ | _ | ⟨x, x', hx'⟩),
      { exact ⟨λ a, (this a).elim, λ a, (this a).elim, λ a, (this a).elim⟩ },
      { rw fintype.card_eq_one_iff at this,
        rcases this with ⟨x, hx⟩,
        have ht := h {x},
        simp only [filter_congr_decidable, exists_prop, exists_eq_left, mem_singleton,
          card_singleton] at ht,
        obtain ⟨y, hy⟩ : (filter (r x) univ).nonempty,
        { rw ← finset.card_pos,
          apply ht },
        simp only [true_and, mem_filter, mem_univ] at hy,
        refine ⟨λ _, y, λ x₁ x₂ z, _, _⟩,
        { rw [hx x₁, hx x₂] },
        { intro x,
          rcases hx x,
          apply hy } },
      { have : (∀ (A : finset α),
                  A.nonempty → A ≠ univ → A.card < (univ.filter (λ b, ∃ a ∈ A, r a b)).card) ∨
              (∃ (A : finset α),
                  A.nonempty ∧ A ≠ univ ∧ A.card = (univ.filter (λ b, ∃ a ∈ A, r a b)).card),
        { rw or_iff_not_imp_right,
          push_neg,
          intros t A Ant Ap,
          apply lt_of_le_of_ne,
          { convert h A },
          { apply t A Ant Ap } },
        rcases this with (q | ⟨A, Ant, Ap, Beq⟩),
        { have h₁ : ({x} : finset α) ≠ univ,
          { intro t,
            apply hx',
            rw [eq_comm, ← finset.mem_singleton, t],
            simp },
          replace h₁ := q {x} (finset.singleton_nonempty x) h₁,
          simp only [filter_congr_decidable, exists_prop, exists_eq_left, mem_singleton,
            card_singleton] at h₁,
          obtain ⟨y, hy⟩ : ∃ y, r x y,
          { obtain ⟨y, hy⟩ : (filter (r x) univ).nonempty,
            { rw ← finset.card_pos,
              apply lt_of_le_of_lt _ h₁,
              apply nat.zero_le },
            exact ⟨y, by simpa using hy⟩ },
          let r' : {x' : α // x' ≠ x} → {y' : β // y' ≠ y} → Prop := λ x' y', r x'.1 y'.1,
          have hr'₁ : fintype.card {x' // x' ≠ x} ≤ n,
          { rw ← nat.succ_le_succ_iff,
            apply le_trans _ hn,
            apply le_of_eq,
            rw [fintype.card_of_subtype (univ.erase x), finset.card_erase_of_mem, card_univ,
              nat.succ_pred_eq_of_pos],
            rw [gt_iff_lt, fintype.card_pos_iff],
            refine ⟨x⟩,
            { simp },
            simp },
          obtain ⟨f, hf₁, hf₂⟩ := ih r' hr'₁ _,
          { refine ⟨λ t, if h : t = x then y else f ⟨t, h⟩, _, _⟩,
            { intros t₁ t₂ z,
              dsimp at z,
              split_ifs at z with h₁ h₂ h₃ h₄,
              { rw [h₁, h₂] },
              { exfalso, apply (f ⟨t₂, h₂⟩).2 z.symm },
              { exfalso, apply (f ⟨t₁, h₁⟩).2 z },
              { rw ← subtype.ext_iff at z,
                apply subtype.ext_iff.1 (hf₁ z) } },
            { intros x₁,
              split_ifs with h₁ h₁,
              { rcases h₁,
                apply hy },
              { exact hf₂ ⟨x₁, h₁⟩ } } },
          intro A,
          rcases eq_empty_or_nonempty A with (rfl | Ane),
          { simp },
          { have : A.image subtype.val ≠ univ,
            { intro t,
              have : x ∉ A.image subtype.val,
              { simp },
              apply this,
              simp [t] },
            rw ← finset.card_image_of_injective _ (@subtype.val_injective _ (λ x', x' ≠ x)),
            apply nat.le_of_lt_succ,
            have := q (A.image subtype.val) (Ane.image subtype.val) ‹_›,
            apply lt_of_lt_of_le (q (A.image subtype.val) (Ane.image subtype.val) ‹_›),
            rw ← finset.card_image_of_injective _ (@subtype.val_injective _ (λ y', y' ≠ y)),
            rw nat.succ_eq_add_one,
            rw ← @finset.card_insert_of_not_mem _ _ y,
            { apply card_le_of_subset,
              intros t,
              simp only [mem_image, true_and, and_imp, exists_prop, mem_filter, mem_insert,
                exists_and_distrib_right, mem_univ, exists_eq_right, subtype.exists, subtype.coe_mk,
                exists_imp_distrib],
              intros x'' x''x hx'' rx''t,
              by_cases (t = y),
              { left,
                apply h },
              { right,
                exact ⟨h, _, _, hx'', rx''t⟩ } },
            simp } },
        { let r₁ : {x' : α // x' ∈ A} → {y' : β // ∃ x' ∈ A, r x' y'} → Prop := λ x y, r x.1 y.1,
          let r₂ : {x' : α // x' ∉ A} → {y' : β // ¬(∃ x' ∈ A, r x' y')} → Prop := λ x y, r x.1 y.1,
          obtain ⟨f, hf₁, hf₂⟩ := ih r₁ _ _,
          obtain ⟨g, hg₁, hg₂⟩ := ih r₂ _ _,
          { refine ⟨λ a, if h₁ : a ∈ A then (f ⟨a, h₁⟩).1 else (g ⟨a, h₁⟩).1, _, _⟩,
            { intros a₁ a₂ q,
              dsimp only at q,
              split_ifs at q with h₁ h₂ h₃ h₄,
              { rw ← subtype.ext_iff_val at q,
                apply subtype.ext_iff.1 (hf₁ q) },
              { exfalso,
                apply (g ⟨a₂, h₂⟩).2,
                simp_rw [←q],
                apply (f ⟨a₁, h₁⟩).2 },
              { exfalso,
                apply (g ⟨a₁, h₁⟩).2,
                simp_rw [q],
                apply (f ⟨a₂, h₃⟩).2 },
              { rw ← subtype.ext_iff_val at q,
                apply subtype.ext_iff.1 (hg₁ q) } },
            { intro x,
              split_ifs with h₁ h₁,
              { apply hf₂ ⟨x, h₁⟩ },
              { apply hg₂ ⟨x, h₁⟩ } } },
          { rw fintype.card_of_subtype Aᶜ _,
            { apply nat.le_of_lt_succ,
              apply lt_of_lt_of_le _ hn,
              rw ← finset.card_univ,
              apply card_lt_card,
              rw ssubset_iff_of_subset (subset_univ _),
              simp only [mem_univ, mem_compl, not_not, exists_prop_of_true],
              apply Ant },
            { simp } },
          { intro B,
            rw ← finset.card_image_of_injective _ (@subtype.val_injective _ (λ x', x' ∉ A)),
            rw ← finset.card_image_of_injective _ (@subtype.val_injective β _),
            transitivity (A ∪ B.image subtype.val).card - A.card,
            { rw [card_disjoint_union, nat.add_sub_cancel_left],
              rw disjoint_left,
              simp only [mem_image, not_exists, subtype.forall],
              rintro a ha a' ha' ht rfl,
              apply ha' ha },
            transitivity ((univ.filter (λ b, ∃ a ∈ A ∪ B.image subtype.val, r a b)).card) - (univ.filter (λ b, ∃ a ∈ A, r a b)).card,
            { rw ← Beq,
              apply nat.sub_le_sub_right,
              convert h (A ∪ image subtype.val B) },
            rw ← card_sdiff,
            { apply card_le_of_subset,
              intros t ht,
              simp only [not_exists, mem_image, true_and, exists_prop, mem_union, mem_filter,
                not_and, mem_sdiff, exists_and_distrib_right, mem_univ, exists_eq_right,
                subtype.exists, subtype.coe_mk] at ht,
              simp only [mem_image, true_and, exists_prop, mem_filter, exists_and_distrib_right,
                mem_univ, exists_eq_right, subtype.exists, subtype.coe_mk],
              rcases ht with ⟨⟨a, ha, rat⟩, ha₂⟩,
              replace ha := or.resolve_left ha _,
              { rcases ha with ⟨ha₁, hB⟩,
                refine ⟨_, a, ha₁, hB, rat⟩,
                push_neg,
                apply ha₂ },
              intro z,
              apply ha₂ _ z rat },
            intro t,
            simp only [mem_filter, mem_univ, true_and],
            rintro ⟨a, ha, rat⟩,
            simp only [mem_image, exists_prop, exists_and_distrib_right, exists_eq_right,
              subtype.exists, subtype.coe_mk],
            refine ⟨a, _, rat⟩,
            rw mem_union,
            left,
            assumption },
          { rw fintype.card_of_subtype A,
            { apply nat.le_of_lt_succ,
              apply lt_of_lt_of_le _ hn,
              rw ← finset.card_univ,
              apply card_lt_card,
              split,
              { apply subset_univ },
              { intro t,
                apply Ap,
                apply finset.subset.antisymm (subset_univ _) t } },
            simp },
          { intro B,
            rw ← finset.card_image_of_injective _ (@subtype.val_injective _ (λ x', x' ∈ A)),
            apply le_trans (h _),
            rw ← finset.card_image_of_injective _ (@subtype.val_injective _ (λ y', ∃ (x' ∈ A), r x' y')),
            apply card_le_of_subset,
            intro t,
            simp only [mem_image, true_and, and_imp, exists_prop, mem_filter, mem_univ,
              exists_and_distrib_right, exists_eq_right, subtype.exists, subtype.coe_mk,
              exists_imp_distrib],
            intros x'' hx'' hB rx''t,
            refine ⟨⟨_, hx'', rx''t⟩, _, _, _, rx''t⟩,
            apply hx'',
            apply hB } } } } },
  { rintro ⟨f, hf₁, hf₂⟩ A,
    rw ← finset.card_image_of_injective A hf₁,
    apply card_le_of_subset,
    intros y hy,
    simp only [true_and, exists_prop, mem_filter, mem_univ],
    simp only [mem_image, exists_prop] at hy,
    rcases hy with ⟨a, ha₁, rfl⟩,
    exact ⟨a, ha₁, hf₂ _⟩ },
end
